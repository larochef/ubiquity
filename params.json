{"name":"Ubiquity","body":"### Welcome to Ubiquity\r\nUbiquity is a utility framework used to copy objects into other objects that may not be compatible.\r\n\r\n### Why ubiquity ?\r\n- Ubiquity is fast\r\nWhen some other popular tools (like beanutils or dozer) use reflexion, Ubiquity parses the bytecode of classes and generates copiers on the fly. Thus, the code wil call \"new\" to create objets and use getters and setters directly. \r\nSince it doesn't use reflexion, it is dramatically faster, you can expect your copy times to be divided by 10 !! The tests I made showed Ubiquity is about 3 times faster than Orika, and about 20 times faster than Dozer. If you have tests showing different resuls, feel free to send me them.\r\n- Ubiquity performs recursive deep copy, and will go as deep as possible\r\n- Support different logging systems, you choose the one you want\r\n- Ubiquity only needs asm to work, nothing more ! All other dependencies are optionnal, and not needed unless you use them.\r\n\r\n### Getting ubiquity\r\nYou can get ubiquity with this link : [https://github.com/downloads/larochef/ubiquity/ubiquity-1.0-rc5.jar](https://github.com/downloads/larochef/ubiquity/ubiquity-1.0-rc5.jar) If ubiquity grows enough in popularity, I will do my best for it to be on maven central !\r\n\r\n### Getting started\r\nUsing ubiquity is as simple as :\r\n```\r\nUbiquity ubiquity = new Ubiquity();\r\nMyObject1 myObject1 = new MyOject1();\r\n// populate and have fun with your object\r\nMyObject2 myObject2 = ubiquity.map(myObject1, MyObject2.class);\r\n```\r\n### Configuration : working with collections and maps\r\n#### Framework support\r\nUbiquity support copying collections and maps, as long as you respect a few rules :\r\n- List and maps should be declared by their interface\r\n- Lists and maps must be parametrized\r\n\r\nThe different types of collections supported are :\r\n```\r\njava.util.Collection\r\njava.util.List\r\njava.util.Set\r\njava.util.Map\r\n```\r\n#### Configuring the implementations of collections\r\nTo specify your favorite implementations of collections, all you have to do is to provide your Ubiquity with a CollectionFactory.\r\n```\r\npackage org.ubiquity;\r\n\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Factory for the different kinds of common collections.\r\n * Implementing this interface allows you to choose the implementations.\r\n *\r\n * Date: 24/04/12\r\n *\r\n * @author François LAROCHE\r\n */\r\npublic interface CollectionFactory {\r\n\r\n    /**\r\n     * Create a new List\r\n     * @param <T>  the type of objects that can be added to the list\r\n     * @return a new list, for objects of type T\r\n     */\r\n    <T> List <T> newList();\r\n\r\n    /**\r\n     * Create a new set\r\n     * @param <T>  the type of objects that can be added to the set\r\n     * @return a new set, for objects of type T\r\n     */\r\n    <T> Set<T> newSet();\r\n\r\n    /**\r\n     * Creates a new map\r\n     *\r\n     * @param <K> the type associated to the keys\r\n     * @param <T> the type associated to the objects\r\n     * @return a new map\r\n     */\r\n    <K,T> Map<K,T> newMap();\r\n\r\n    /**\r\n     * Default collection creation\r\n     * @param <T> the type of elments to store in the collection\r\n     * @return a new Collection for objects of type T\r\n     */\r\n    <T>Collection<T> newCollection();\r\n}\r\n```\r\nDefaults are :\r\n- java.util.ArrayList for java.util.List or java.util.Collection\r\n- java.util.HashSet for java.util.Set\r\n- java.util.HashMap for java.util.Map\r\n\r\n### Dealing with special cases\r\nThere will be cases when all that's provided will not be enough. These cases can be, for exemple, converting from an enum to another one, or dealing with other special objects. \r\nFor all these special cases, you can tell Ubiquity how to copy a class to another one. All you have to do is create a copier implementing org.ubiquity.Copier, or you can extend, if it meets your need the org.ubiquity.bytecode.SimpleCopier class. Then, you can simply define it :\r\n```\r\nubiquity.setCopier(SrcClass.class, DestinationClass.class, myCopier);\r\n```\r\nThen, any copy done by this ubiquity object from SrcClass to DestinationClass will use this copier.\r\n\r\n### Property matching\r\nBy default, every getter or setter will be taken into account, which means that a read-only property can be copier into a write only property !\r\nProperties are matched by name.\r\n#### Ignoring a property\r\nIf you want to have a property no copied, just annote it with \r\n```\r\n@org.ubiquity.annotation.CopyIgnore\r\n```\r\n#### Renaming a property\r\nUbiquity supports renaming properties and also allow multiple renaming configuration according to the target object class.\r\nWhen multiple configurations exist, Ubiquity will, at first, try to match a renaming for the target class. If none exist, it will take the default configuration (which will be with no target class, or java.lang.Object). If no configuration is found, then the property isn't renamed.\r\n```\r\n@org.ubiquity.annotation.CopyRename(propertyName=\"property2\")\r\npublic String getProperty1() {...}\r\n```\r\n```\r\n@org.ubiquity.annotation.CopyRenames(configurations={\r\n@org.ubiquity.annotation.CopyRename(propertyName=\"property2\"),\r\n@org.ubiquity.annotation.CopyRename(propertyName=\"property3\", targetClass=DestinationClass.class)\r\n}\r\npublic String getProperty1() {...}\r\n```\r\nAt the moment, you cannot rename to a nested property, which means,\r\n```\r\n@org.ubiquity.annotation.CopyRename(propertyName=\"property2.property3\")\r\npublic String getProperty1() {...}\r\n```\r\n**will throw an Exeption.**\r\n\r\n\r\n### Support or Contact\r\nPlease have fun with it ! If you have any trouble, please use all the feedback tools to let me know.\r\nFrançois LAROCHE","tagline":"Copy java objects","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}